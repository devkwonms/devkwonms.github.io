[ { "title": "코딩테스트 3. 키패드 누르기", "url": "/posts/CodingTest3/", "categories": "CodingTest, Programmers-Level-1", "tags": "느리지만 확실하게 !, langsam aber sicher, Java", "date": "2022-05-27 17:00:00 +0900", "snippet": "문제 설명스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.맨 처음 왼손 엄지손가락은 * 키패드에 오른손 엄지손가락은 # 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다.왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다.오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다.가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.4-1. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요.[제한사항] numbers 배열의 크기는 1 이상 1,000 이하입니다. numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다. hand는 &quot;left&quot; 또는 &quot;right&quot; 입니다. &quot;left&quot;는 왼손잡이, &quot;right&quot;는 오른손잡이를 의미합니다. 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요.입출력 예|numbers |hand |result||:—|—:|—:||[1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] |”right” |”LRLLLRLLRRL”||[7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] |”left” |”LRLLRRLLLRR”||[1, 2, 3, 4, 5, 6, 7, 8, 9, 0] |”right” |”LLRLLRLLRL”|입출력 예 #1순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다.|왼손 위치| 오른손 위치 |눌러야 할 숫자 |사용한 손| 설명||:—|:—|:—|:—|:—||* |#| 1|L |1은 왼손으로 누릅니다.||1 |#| 3|R |3은 오른손으로 누릅니다.||1 |3| 4|L |4는 왼손으로 누릅니다.||4 |3| 5|L |왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.||5 |3| 8|L |왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다.||8 |3| 2|R |왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다.||8 |2| 1|L |1은 왼손으로 누릅니다.||1 |2| 4|L |4는 왼손으로 누릅니다.||4 |2| 5|R |왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다.||4 |5| 9|R |9는 오른손으로 누릅니다.||4 |9| 5|L |왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.||5 |9| -|- ||따라서 “LRLLLRLLRRL”를 return 합니다.입출력 예 #2왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 “LRLLRRLLLRR”이 됩니다.입출력 예 #3오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 “LLRLLRLLRL”이 됩니다.풀이import java.util.HashMap;class Solution { public String solution(int[] numbers, String hand) { int[][] pad = new int[4][3]; HashMap&amp;lt;Integer, int[]&amp;gt; position = new HashMap&amp;lt;&amp;gt;(); int left = 10; int right = 12; int init = 1; String answer = &quot;&quot;; for (int i = 0; i &amp;lt; pad.length; i++) { //초기 패드 설정 및 위치좌표 설정 ex) 1=&amp;gt;{0,1} for (int j = 0; j &amp;lt; pad[i].length; j++) { pad[i][j] = init; int[] positionArr = new int[2]; positionArr[0] = i; positionArr[1] = j; position.put(init, positionArr); if (init==11) { position.put(0, positionArr); position.remove(11); } init++; } } for (int i = 0; i &amp;lt; numbers.length; i++) { if (numbers[i] == 1 || numbers[i] == 4 || numbers[i] == 7) { //147이면 왼손 left = numbers[i]; answer += &quot;L&quot;; } else if (numbers[i] == 3 || numbers[i] == 6 || numbers[i] == 9) {//369면 오른손 right = numbers[i]; answer += &quot;R&quot;; } else { int[] goal = position.get(numbers[i]); int leftMove = Math.abs(position.get(left)[0] - goal[0]) + Math.abs((position.get(left)[1] - goal[1])); //좌표 절대값 비교하여 가까운 손찾기 int rightMove = Math.abs(position.get(right)[0] - goal[0]) + Math.abs((position.get(right)[1] - goal[1])); if (leftMove &amp;lt; rightMove) { left = numbers[i]; answer += &quot;L&quot;; } if (rightMove &amp;lt; leftMove) { right = numbers[i]; answer += &quot;R&quot;; } if (leftMove == rightMove) { if (hand.equals(&quot;left&quot;)) { left = numbers[i]; answer += &quot;L&quot;; } else { right = numbers[i]; answer += &quot;R&quot;; } } } } return answer; } public static void main(String[] args) { Solution s = new Solution(); int[] numbers = {1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5}; String hand = &quot;right&quot;; }}" }, { "title": "코딩테스트 2. 숫자열과 영단어", "url": "/posts/CodingTest2/", "categories": "CodingTest, Programmers-Level-1", "tags": "느리지만 확실하게 !, langsam aber sicher, Java", "date": "2022-05-26 17:00:00 +0900", "snippet": "문제 설명네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다. 1478 → “one4seveneight” 234567 → “23four5six7” 10203 → “1zerotwozero3”이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다. 숫자 영단어 0 zero 1 one 2 two 3 three 4 four 5 five 6 six 7 seven 8 eight 9 nine 제한사항1 ≤ s의 길이 ≤ 50s가 zero 또는 0으로 시작하는 경우는 주어지지 않습니다.return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다.입출력 예 s result “one4seveneight” 1478 “23four5six7” 234567 “2three45sixseven” 234567 “123” 123 입출력 예 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #2문제 예시와 같습니다.입출력 예 #3three는 3, six는 6, seven은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다.입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.입출력 예 #4s에는 영단어로 바뀐 부분이 없습니다.제한시간 안내정확성 테스트 : 10초풀이import java.util.Arrays;import java.util.HashMap;public class solution { public int solution(String s) { String answerStr = &quot;&quot;; HashMap&amp;lt;String,String&amp;gt; temp = new HashMap&amp;lt;&amp;gt;(); temp.put(&quot;zero&quot;,&quot;0&quot;); temp.put(&quot;one&quot;,&quot;1&quot;); temp.put(&quot;two&quot;,&quot;2&quot;); temp.put(&quot;three&quot;,&quot;3&quot;); temp.put(&quot;four&quot;,&quot;4&quot;); temp.put(&quot;five&quot;,&quot;5&quot;); temp.put(&quot;six&quot;,&quot;6&quot;); temp.put(&quot;seven&quot;,&quot;7&quot;); temp.put(&quot;eight&quot;,&quot;8&quot;); temp.put(&quot;nine&quot;,&quot;9&quot;); String tempStr=&quot;&quot;; String[] sArray = s.split(&quot;&quot;); for(int i=0; i&amp;lt;sArray.length;i++){ if (sArray[i].matches(&quot;[a-z]&quot;)){ tempStr+=sArray[i]; if(temp.containsKey(tempStr)){ answerStr+=temp.get(tempStr); tempStr=&quot;&quot;; } }else if(sArray[i].matches(&quot;[0-9]&quot;)){ answerStr+=sArray[i]; } } int answer = Integer.parseInt(answerStr); return answer; } public static void main(String[] args) { solution ss = new solution(); ss.solution(&quot;one4seveneight&quot;); }}/*//replaceAll을 깜빡했다.. String[] arr = {&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;}; for (int i = 0; i &amp;lt; arr.length; i++) { s.replaceAll(arr[i],String.valueOf(i)); } answer = Integer.parseInt(s);//이런식으로 해도될듯*/" }, { "title": "코딩테스트 1. 로또 경우의수 (프로그래머스)", "url": "/posts/CodingTest1/", "categories": "CodingTest, Programmers-Level-1", "tags": "느리지만 확실하게 !, langsam aber sicher, Java", "date": "2022-05-23 17:00:00 +0900", "snippet": "문제 설명 순위 당첨 내용 1 6개 번호가 모두 일치 2 5개 번호가 일치 3 4개 번호가 일치 4 3개 번호가 일치 5 2개 번호가 일치 6(낙첨) 그 외 로또 6/45(이하 ‘로또’로 표기)는 1부터 45까지의 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다.로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.알아볼 수 없는 번호를 0으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 44, 1, 0, 0, 31 25라고 가정해보겠습니다. 당첨 번호 6개가 31, 10, 45, 1, 6, 19라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다. 당첨 번호 31 10 45 1 6 19 결과 최고 순위 번호 31 0→10 44 1 0→6 25 4개 번호 일치,3등 최저 순위 번호 31 0→11 44 1 0→7 25 2개 번호 일치,5등 순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다.알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다.3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다.알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다.5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다.민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.제한사항 lottos는 길이 6인 정수 배열입니다. lottos의 모든 원소는 0 이상 45 이하인 정수입니다. 0은 알아볼 수 없는 숫자를 의미합니다. 0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다. lottos의 원소들은 정렬되어 있지 않을 수도 있습니다. win_nums은 길이 6인 정수 배열입니다. win_nums의 모든 원소는 1 이상 45 이하인 정수입니다. win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다. win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다.입출력 예 lottos win_nums result [44, 1, 0, 0, 31, 25] [31, 10, 45, 1, 6, 19] [3, 5] [0, 0, 0, 0, 0, 0] [38, 19, 20, 40, 15, 25] [1, 6] [45, 4, 35, 20, 3, 9] [20, 9, 3, 45, 4, 35] [1, 1] 입출력 예 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #2알아볼 수 없는 번호들이 아래와 같았다면, 1등과 6등에 당첨될 수 있습니다. 당첨 번호 38 19 20 40 15 25 결과 최고 순위 번호 0→38 0→19 0→20 0→40 0→15 0→25 6개 번호 일치, 1등 최저 순위 번호 0→21 0→22 0→23 0→24 0→26 0→27 0개 번호 일치, 6등 입출력 예 #3민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다.풀이import java.util.Arrays;public class solution { public int[] solution(int[] lottos, int[] win_nums) { int[] rank = {6,6,5,4,3,2,1}; int zeros = 0; int count = 0; for (int i = 0; i &amp;lt; lottos.length; i++) { if (lottos[i]==0){ zeros++; continue; } for (int a : win_nums){ if (lottos[i] == a) count++; } } int[] answer = {rank[count+zeros],rank[count] }; return answer; } public static void main(String[] args) { solution l = new solution();// int[] lottos = {44, 1, 0, 0, 31, 25};// int[] win_nums ={31, 10, 45, 1, 6, 19};// // result [3, 5]// int[] lottos = {0, 0, 0, 0, 0, 0};// int[] win_nums ={38, 19, 20, 40, 15, 25};// // result [1, 6] int[] lottos = {45, 4, 35, 20, 3, 9}; int[] win_nums ={20, 9, 3, 45, 4, 35}; // result [1, 1] Arrays.stream(l.solution(lottos, win_nums)).forEach(System.out::println); }}" }, { "title": "Linux/리눅스 자바 백그라운드에서 프로세스 하기", "url": "/posts/linux1/", "categories": "Coding, Java", "tags": "Java, Linux, Nohup, Programming", "date": "2022-05-17 02:32:00 +0900", "snippet": " java -jar {실행 할 jar이름.jar}## ex java -jar abc.jar위와 같이 명령을 주면 해당 콘솔을 닫게 되는 순간 켜져있던 프로세스가 종료된다.aws등으로 서버를 돌리고 다른곳에서 항시 접속하기 위한 방법으로는 백그라운드로 서버 자체에서 프로세싱 하는 방법인데 이를 위한 명령어가 nohup 이다.nohup java -jar {실행 할 jar이름.jar} &amp;amp;## ex) nohup java -jar abc.jar &amp;amp; &amp;lt;-- &#39;&amp;amp;&#39; 넣어주기이후에는 콘솔창을 닫아도 상관없이 서버의 자바서버와 연결이 가능하게 된다종료$ ps -ef | grep java -jar {사용할 jar 이름} # 또는 ps -ef | grep {쉘스크립트파일} ## ex) ps -ef | grep java -jar abc.jar## 또는 ps -ef | grep java 를 친 후 PID 를 확인하면된다## 위에서 확인한 PID를 이용하여 프로세스 종료$ kill -9 {PID}" }, { "title": "TypeScript 001. JavaScript와 TypeScript", "url": "/posts/TypeScript1/", "categories": "Coding, TypeScript", "tags": "JaveScript, TypeScript, Dev, Programming", "date": "2022-03-20 08:32:00 +0900", "snippet": "JavaScript의 짧은 역사 (What is JavaScript? A Brief History)JavaScript는 처음에 브라우저를 위한 스크립팅 언어로 만들어졌다. JavaScript가 처음 나왔을 때, 수십 줄 이상의 코드를 작성하는 것은 다소 이례적인 일이었기에 웹 페이지 속 짧은 코드들을 위해 사용할 것으로 여겨졌다고 한다. 때문에, 초기 웹 브라우저들은 수십 줄 이상의 코드를 실행하는데 오래 걸렸는데, 시간이 흘러 JS가 점점 더 유명해지면서, 웹 개발자들은 JS를 이용해 상호작용을 하는 경험을 하기 시작했다고 한다.웹 브라우저 개발자들은 위와 같이 늘어나는 JS 사용량에 대하여 실행 엔진(동적 컴파일)을 최적화시키고 최적화 된 것을 이용해 할 수 있는 일(API 추가)을 확장하여 웹 개발자가 더 많이 JS를 사용할 수 있게 했다. 현대 웹사이트에서, 브라우저는 수십만 줄의 코드로 구성된 어플리케이션을 자주 실행한다. 이는 정적 페이지의 간단한 네트워크로 시작해서, 모든 종류의 만족스러울만한 어플리케이션을 위한 플랫폼으로 성장한 “웹”의 길고 점진적인 성장이다.이외에도, JS는 node.js를 사용하여 JS 서버들을 구현하는 것처럼, 브라우저 맥락에서 벗어나는 일에 사용하기 충분할 정도로 유명해졌다. “어디서든 작동됨”과 같은 JS의 성질은 교차 플랫폼(cross-platform) 개발을 위한 매력적인 선택지이기도 하다. 오늘날 많은 개발자들은 오직 JavaScript만을 이용하여 전체 스택을 프로그래밍하고 있다!요약하자면, 우리에게는 빠른 사용을 위해 설계되었으며 수백만 줄의 어플리케이션들을 작성하기 위해 만들어진 완벽한 도구인 JavaScript가 있다. 모든 언어는 각자의 별난 점 - 이상한 점과 놀랄만한 점이 있으며, JavaScript의 자랑스럽지만은 않은 시작은 많은 문제를 만들게 되었다. 예를 들어: JavaScript의 동일 연산자는 (==) 인수를 강제로 변환하여(coerces), 예기치 않은 동작을 유발한다:if(&quot;&quot; == 0) {// 참이다! 근데 왜죠??} //error xif (1 &amp;lt; x &amp;lt; 3) {// *어떤* x 값이던 참이다!} //error x JavaScript는 또한 존재하지 않는 프로퍼티의 접근을 허용한다:const obj = { width: 10, height: 15 };// 왜 이게 NaN이죠? 철자가 어렵네요!const area = obj.width * obj.heigth;// ^오타console.log(area)//NaN // error xTypeScript: 정적 타입 검사자 (TypeScript: A Static Type Checker)Java 와 같은 몇 언어는 버그가 있는 프로그램을 아예 실행시키지 않는다. 프로그램을 실행시키지 않으면서 코드의 오류를 검출하는 것을 정적 검사 (컴파일 시) 라고 한다. 어떤 것이 오류인지와 어떤 것이 연산 되는 값에 기인하지 않음을 정하는 것이 정적 타입 검사다.정적 타입 검사자인 TypeScript는 프로그램을 실행시키기 전에 값의 종류를 기반으로 프로그램의 오류를 찾는다. 예를 들어, 위의 마지막 예시에 오류가 있는 이유는 obj의 타입 때문이다. 다음은 TypeScript에서 볼 수 있는 오류이다://@errors: 2551 const obj = { width: 10, height: 15 };const area = obj.width \\* obj.heigth;타입이 있는 JavaScript의 상위 집합 (A Typed Superset of JavaScript)그렇다면 TypeScript는 JavaScript와 어떤 관계일까요?구문 (Syntax)TypeScript는 JS의 구문이 허용되는, JavaScript의 상위 집합 언어이다. 구문은 프로그램을 만들기 위해 코드를 작성하는 방법을 의미한다. 예를 들어, 다음 코드는 )이 없으므로 구문 오류이다:// @errors: 1005let a = (4TypeScript는 독특한 구문 때문에 JavaScript 코드를 오류로 보지 않는다. 즉, 어떻게 작성돼있는지 모르지만 작동하는 JavaScript 코드를 TypeScript 파일에 넣어도 잘 작동한다.타입 (Types)그러나 TypeScript는 타입이 있는 상위 집합이다. 위의 obj.heigth 오류는 구문 오류가 아닌, 값의 종류(타입)를 잘못 사용해서 생긴 오류이다.또 다른 예시로, 아래와 같은 JavaScript 코드가 브라우저에서 실행될 때, 다음과 같은 값이 출력될 것이다:console.log(4 / []);구문적으로 옳은(syntactically-legal) 위 코드는 JavaScript에서 NaN을 출력한다.그러나 TypeScript는 배열로 숫자를 나누는 연산이 옳지 않다고 판단하고 오류를 발생시킨다:// @errors: 2363console.log(4 / []);만약 JavaScript 파일의 코드를 TypeScript 코드로 옮기면, 코드를 어떻게 작성했는지에 따라 타입 오류를 볼 수 있다.런타임 특성 (Runtime Behavior)TypeScript는 JavaScript의 런타임 특성을 가진 프로그래밍 언어이다. 예를 들어, JavaScript에서 0으로 나누는 행동은 런타임 예외로 처리하지 않고 Infinity값을 반환한다. 논리적으로, TypeScript는 JavaScript 코드의 런타임 특성을 절대 변화시키지 않는다.즉 TypeScript가 코드에 타입 오류가 있음을 검출해도, JavaScript 코드를 TypeScript로 이동시키는 것은 같은 방식으로 실행시킬 것을 보장한다JavaScript와 동일한 런타임 동작을 유지하는 것은 프로그램 작동을 중단시킬 수 있는 미묘한 차이를 걱정하지 않고 두 언어 간에 쉽게 전환할 수 있도록 하기 위한 TypeScript의 기본적인 약속이다.삭제된 타입 (Erased Types)개략적으로, TypeScript의 컴파일러가 코드 검사를 마치면 타입을 삭제해서 결과적으로 “컴파일된” 코드를 만든다. 즉 코드가 한 번 컴파일되면, 결과로 나온 일반 JS 코드에는 타입 정보가 없다.타입 정보가 없는 것은 TypeScript가 추론한 타입에 따라 프로그램의 특성을 변화시키지 않는다는 의미이다. 결론적으로 컴파일 도중에는 타입 오류가 표출될 수 있지만, 타입 시스템 자체는 프로그램이 실행될 때 작동하는 방식과 관련이 없다.마지막으로, TypeScript는 추가 런타임 라이브러리를 제공하지 않는다. TypeScript는 프로그램은 JavaScript 프로그램과 같은 표준 라이브러리 (또는 외부 라이브러리)를 사용하므로, TypeScript 관련 프레임워크를 추가로 공부할 필요가 없다.JavaScript와 TypeScript 학습 (Learning JavaScript and TypeScript)종종 “JavaScript 또는 TypeScript를 배워야 할까요?”와 같은 질문을 볼 수 있다.정답은 JavaScript를 배우지 않고선 TypeScript를 배울 수 없다는 것이다! TypeScript는 JavaScript와 구문과 런타임 특성을 공유하므로, JavaScript에서 배운 모든 것들은 동시에 TypeScript를 배울 때 도움이 될 것이다.Ref. https://www.typescriptlang.org/ko/docs/handbook/typescript-from-scratch.html(TypeScript)" }, { "title": "파이썬으로 게임만들기", "url": "/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC/", "categories": "Coding, Python", "tags": "느리지만 확실하게 !, langsam aber sicher", "date": "2021-07-05 17:00:00 +0900", "snippet": "자바의 Jframe 과 비슷한 느낌으로 파이썬에도 다양한 모듈이  존재한다.turtle,pygame등 과 같이 게임제작에 더 유용한 모듈도 있지만, 이번에는 Tkinter를 사용하였다.게임은 어렸을 적에 즐겨했지만 몇 년전 서비스를 종료해 이제는 즐길 수 없는수 많은 큐플레이 게임 중 햄버거 게임을 구현해보았다.큐플레이의 햄버거 게임내 햄버거 게임원작 게임은 푸드트럭 느낌이지만, 재구성하여 포장마차 햄버거 느낌으로 만들었다.게임 내에 모든 로직과 기능구현들을 직접 짰고,웬만한 이미지들도 모두 직접 그려 넣었다. 1.첫화면우선 게임을 처음 실행하였을 때 나오는 창은 아래와 같다.첫 화면햄버거 메뉴 문제를 만들어준 동기들의 메뉴를 선보이며 첫 화면을 구성하였다.시작 화면시작 버튼을 누르면 화면이 전환되고 카운트 다운과 함께 게임이 시작된다.2. 게임 화면키보드 방향키를 이용하여 재료를 선택하고 SpaceBar를 눌러 재료를 쌓는다.정답 시제한시간은 60초이고 순서대로 재료를 쌓아 정답을 맞히면 정답 표시와 함께점수가 올라가고 화면에서 갱신되며, 다음 문제로 넘어간다.최고점수는 게임 실행 후 최고점수를 의미한다.오답 시틀리게 되면 점수는 올라가지 않고,정답과 마찬가지로 문제가 바뀌며 만들던 햄버거는 사라진다.제한시간 10초제한시간이 10초가 남게되면 타이머가 빨간색으로 변한다.3.게임 종료 및 재시작시간초과시간이 다 되면 모든 이미지가 지워지고 거대 햄버거가 나타나며 게임은 종료된다. Restart버튼을 누르면 카운트와 함께 재시작된다.재시작정답을 맞히거나 틀리거나, 게임 오버가되면 버튼을 눌러도 작동하지 않는다.재시작을 하게 되면 현재 점수는 초기화되고 최고점수는 유지되어 다시 갱신을 할 수 있다. 코드: https://github.com/Braveleftji/port/blob/main/Hambuck.py" }, { "title": "자바 입문기 5.클래스", "url": "/posts/%EC%9E%90%EB%B0%9405%ED%81%B4%EB%9E%98%EC%8A%A4/", "categories": "Coding, Java", "tags": "느리지만 확실하게 !, langsam aber sicher", "date": "2021-05-22 17:00:00 +0900", "snippet": "Java는 백기선님의 유튜브를 통해 공부한다.목표자바의 Class에 대해 학습하세요.학습할 것 (필수) 클래스 정의하는 방법 객체 만드는 방법 (new 키워드 이해하기) 메소드 정의하는 방법 생성자 정의하는 방법 this 키워드 이해하기클래스 정의하는 방법 Ref클래스의 개념객체 지향 프로그래밍(OOP, Object-Oriented Programming)객체 지향 프로그래밍에서는 모든 데이터를 객체(object)로 취급하는데,객체(object)는 대개 붕어빵으로 비유된다.이러한 객체(붕어빵)의 상태와 행동을 구체화하는 형태의 프로그래밍이 바로 객체 지향 프로그래밍이다.클래스(class)자바에서 클래스(class)란 객체를 정의하는 틀(붕어빵틀)과 같다.클래스는 객체의 상태를 나타내는 필드(field)=변수(variable)와 객체의 행동을 나타내는 메소드(method)로 구성된다.인스턴스(instance)자바에서 클래스를 사용하려면해당 클래스 타입의 객체(object)를 선언해야 한다.클래스로부터 객체를 선언하는 과정을 인스턴스 화라고 하고,인스턴스는 메모리에 할당된 객체를 의미한다.자바에서는 하나의 클래스로부터 여러 개의 인스턴스를 생성할 수 있다.이렇게 생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드를 가진다.하지만 해당 클래스의 모든 메소드(method)는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 된다.클래스의 예 ex)클래스(class) &amp;lt;- 차라고 정의 Car필드(field) &amp;lt;- Car(차)들의 속성 modelName = &quot;람보르기니&quot; modelYear = 2016 color = &quot;주황색&quot; maxSpeed = 350메소드(method) &amp;lt; - 차들의 행동 accelerate() brake()인스턴스(instance) &amp;lt; - 객체 내 차(myCar) : 설계도에 의해 생산된 차량 &amp;lt; = `내 차` 라는 객체 친구 차(friendCar) : 설계도에 의해 생산된 또 다른 차량&amp;lt; - `친구 차` 라는 객체즉, 자동차 인스턴스는 모두 위와 같은 필드와 메소드를 가지게 된다.하지만 각 인스턴스마다 가지고 있는 값은 전부 다를 것이다.클래스 구성요소class Car { // 클래스 이름 private String modelName; // 필드 private int modelYear; // 필드 Car(String modelName, int modelYear) { // 생성자 this.modelName = modelName; this.modelYear = modelYear; } public String getModel() { // 메소드 return this.modelYear + &quot;년식 &quot; + this.modelName + &quot; &quot; + this.color; }}필드(field)클래스의 필드(field)란 클래스에 포함된 변수(variable)를 의미한다.클래스 내에서 필드는 선언된 위치에 따라 다음과 같이 구분된다. 클래스 변수(static variable) 인스턴스 변수(instance variable) 지역 변수(local variable)지난 포스팅 자바입문기 2에서 자세히 설명해놨다.메소드(method)클래스에서 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.생성자(constructor)생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태이다.자바는 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는생성자(constructor)라는 메소드를 제공한다.클래스의 선언자바에서 클래스를 선언하는 방법은 접근 제어자와 함께 class 키워드를 사용하면 된다.자바에서 클래스는 다음과 같이 선언한다.정의 public class Car{//접근제어자 class 클래스이름 { private String modelName; //접근제어자 필드1의타입 필드1의이름; private int modelYear; //접근제어자 필드2의타입 필드2의이름; ... public void brake(){} //접근제어자 메소드1의 원형 //접근제어자 메소드2의 원형 ...}public 멤버는 모든 객체에서 접근할 수 있지만,private 멤버는 해당 객체 내의 멤버 변수나 메소드만이 접근할 수 있다.클래스에서 사용되는 수식 Ref 접근 제어자 : 적용된 키워드에 따라 해당 객체, 메서드가 가시될 범위를 결정한다. public : 모든 클래스에서 해당 클래스를 참조 가능하다. package-private : 해당 클래스가 포함된 패키지 내에서만 참조 가능하다. (지정이 없는 경우) protect : 서브, 하위 클래스와 동일 패키지 내부에 존재하는 클래스만 참조 가능하다. private : 자기 자신인 객체 내부에서만 참조 가능하다. (인터페이스도 JDK9부터 사용 가능) abstract : 해당 클래스, 메서드에서 구현부를 가지지 않고 상속 시 구현을 강제하는 지정 방식이다. 추상 클래스, 인터페이스에서 사용된다. static : 해당 클래스가 인스턴스화 되어있지 않아도 사용 가능하다는 지정 방식이다. 위에서도 언급하였지만 생성 방식과 시점이 다르다. final : 해당 지정자가 작성된 것에 대해 상속이나 변경을 금지한다는 의미이다.→ 하지만 private가 지정된 메서드나 final class에 대해선 명시하지 않아도 된다. 변수 : 그 필드의 값이 변경되는 것을 금지한다. → 값을 해당 필드에서 초기화하지 않는다면, 생성자를 통한 초기화가 강제된다. 메서드 : 해당 클래스 타입을 상속받는 서브, 하위 클래스에서 오버라이딩을 금지한다.오버라이딩 -&amp;gt;부모클래스등의 메소드의 블럭안의 내용을 하위클래스에서 재정의하여 사용하는 것. 클래스 : 해당 클래스의 상속을 금지한다. (String, Integer…. 등) → 일종의 관례로써 전역적으로 사용되는 static 요소들은 final을 붙인다고 한다. transient : 객체 직렬화 시에 직렬화 대상에서 제외한다. (이 경우 null로 처리된다.) volatile : 해당 지정자가 붙은 변수에 대해서는 스레드가 값을 캐시하지 않고, 메인 메모리에서 처리한다. 시간에 따라서 각 쓰레드가 참조하는 값이 달라지는 것을 방지한다. 하나의 쓰레드가 값을 증가시키고, 여러 쓰레드가 값을 읽는 경우 항상 최신의 값을 제공하기 위해서는 해당 지정자를 사용하는 것이 좋다. → 여러 쓰레드가 값을 증가시키고, 읽는다면 Atomic Variable을 사용하자. sysnchronized : 해당 지정자가 붙은 메서드와 스코프에 스레드 간 동기화를 진행한다는 의미이다. (이후에 알아보자.) native : 해당 지정자가 붙은 메서드는 Java 가 아닌 네이티브 코드를 사용하는 것을 의미한다. C/C++ 등으로 작성된 DDL이나 JNI에서 제공하는 코드를 말한다. strictfp : 해당 지정자가 붙은 Double, Float에 대하여서 IEEE 754 규격을 적용한다는 의미이다. 인터페이스나 메서드에 지정할 수 있다. 객체 만드는 방법 (new 키워드 이해하기)인스턴스의 생성다음과 같은 순서대로 Car 객체의 인스턴스를 생성할 수 있다.우선 다음과 같이 객체를 참조하기 위한 참조 변수를 먼저 선언한다.선언클래스이름 객체참조변수이름;Car myCar;그 후, new 키워드를 사용하여 인스턴스를 생성하고,해당 인스턴스의 주소를 미리 선언한 참조 변수에 저장하여 사용한다.선언객체참조변수이름 = new 클래스이름();myCar = new Car(); 동시에 할 수도 있다.선언클래스이름 객체참조변수이름 = new 클래스이름();Car myCar = new Car();메소드 정의하는 방법 Ref메소드(method)메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.메소드의 사용 목적클래스에서 메소드를 작성하여 사용하는 이유는중복되는 코드의 반복적인 프로그래밍을 피할 수 있고, &amp;lt;-같은 행동(코드)을 따로 메소드로 만들어 준다.모듈화로 인해 코드의 가독성도 좋아지고,문제가 발생하거나 기능의 변경이 필요할 때도 손쉽게 유지보수를 할 수 있게 되기 때문이다.메소드는 작성할 때 되도록 하나의 메소드가 하나의 기능만을 수행하도록 작성하는 것이 좋다.메소드 정의클래스에서 메소드를 정의하는 방법은 일반 함수를 정의하는 방법과 크게 다르지 않다.자바에서 메소드를 정의하는 방법은 다음과 같다.문법접근제어자 반환타입 메소드이름(매개변수목록) { // 선언부 // 구현부} 접근 제어(한)자 : 해당 메소드에 접근할 수 있는 범위를 명시한다. 반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시한다. 메소드 이름 : 메소드를 호출하기 위한 이름을 명시한다. 매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시한다. 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합이다.자바에서는 하나의 클래스에 같은 이름의 메소드를 둘 이상 정의할 수 없다.하지만 메소드 오버로딩(overloading)을 이용하면, 같은 이름의 메소드를 중복하여 정의할 수 있다.메소드 오버로딩메소드 오버로딩이란 매개변수의 개수나 타입을 다르게 메소드이름옆에 `(매개변수)’하여 같은 이름의 또 다른 메소드를 작성하는 것이다. 이러한 메소드 오버로딩을 사용함으로써 메소드에 사용되는 이름을 절약할 수 있다.또한, 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있다.메소드 시그니처(method signature)란 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킵니다. 만약 두 메소드가 매개변수의 개수와 타입, 그 순서까지 모두 같다면, 이 두 메소드의 시그니처는 같다고 할 수 있다.다음 예제는 Car 클래스의 accelerate() 메소드를 정의하는 예제이다.예제class Car { private int currentSpeed; private int accelerationTime; ...// ↓반환타입① public void accelerate (int speed, int second) { // 선언부 //↑접근제어자 ↑메소드이름 (매개변수 , 매개변수 ) System.out.println(second + &quot;초간 속도를 시속 &quot; + speed + &quot;(으)로 가속함!!&quot;); // 구현부 } . . .}위 예제의 ①번 라인에서는 accelerate() 메소드를 정의하고 있다.이 메소드는 public 접근 제어자를 사용하여 선언되어 해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있다.반환 타입에는 어떠한 값도 반환하지 않는다는 의미를 가진void를 명시한다.그 다음으로 메소드의 이름을 명시하고, 매개변수(파라미터)로 int형 변수인 speed와 second를 전달받sms다.이렇게 전달받은 매개변수를 가지고 메소드 구현부에서 고유한 작업을 수행할 수 있는 것이다.메소드 호출자바에서 위와 같은 방법으로 정의한 메소드는 멤버 참조 연산자(.)를 사용하여 호출할 수 있다.자바에서 메소드를 호출하는 방법은 다음과 같다.문법 객체참조변수이름.메소드이름(); // 매개변수가 없는 메소드의 호출 객체참조변수이름.메소드이름(인수1, 인수2, ...); // 매개변수가 있는 메소드의 호출 Car myCar = new Car(); // 객체를 생성함.myCar.accelerate(60, 3); // myCar 인스턴스의 accelerate() 메소드를 호출함.다음 예제는 실제로 accelerate() 메소드를 정의하고 호출하는 예제이다.예제class Car { private int currentSpeed; private int accelerationTime; public void accelerate(int speed, int second){ System.out.println(second + &quot;초간 속도를 시속 &quot; + speed + &quot;(으)로 가속함!!&quot;); }}public class Method01 { public static void main(String[] args) { Car myCar = new Car(); // 객체 생성 myCar.accelerate(60, 3); // 메소드 호출 }}실행 결과3초간 속도를 시속 60(으)로 가속함!!생성자 정의하는 방법 Ref인스턴스 변수의 초기화클래스를 가지고 객체를 생성하면, 해당 객체는 메모리에 즉시 생성된다.하지만 이렇게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태이다.자바에서 클래스 변수와 인스턴스 변수는 별도로 초기화하지 않으면, 다음 값으로 자동 초기화된다. 변수의 타입 초깃값 char ’\\u0000’ byte, short, int 0 long 0L float 0.0F double 0.0 또는 0.0D boolean false 배열, 인스턴스 등 null 생성자(constructor)자바에서는 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자(constructor)라는 메소드를 제공한다.자바에서 생성자(constructor)의 이름은 해당 클래스의 이름과 같아야 한다.즉, Car 클래스의 생성자의 이름은 Car가 된다.이러한 생성자는 다음과 같은 특징을 가진다. 생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않는다. 생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다. 하나의 클래스가 여러 개의 생성자를 가질 수 있다. 즉, 생성자도 하나의 메소드이므로, 메소드 오버로딩이 가능하다는 의미이다. 생성자는 클래스의 이름과 같아야하기 때문에 오버라이딩은 불가능하다.다음 예제는 Car 클래스를 선언하면서 여러 개의 생성자를 선언하는 예제이다.예제Car(String modelName) {}Car(String modelName, int modelYear) {}Car(String modelName, int modelYear, String color) {}Car(String modelName, int modelYear, String color, int maxSpeeds) {}생성자의 선언자바에서 클래스 생성자를 선언하는 문법은 다음과 같다.문법 클래스이름() { ... } // 매개변수가 없는 생성자 선언 클래스이름(인수1, 인수2, ...) { ... } // 매개변수가 있는 생성자 선언 Car(String modelName, int modelYear, String color, int maxSpeeds) { this.modelName = modelName; this.modelYear = modelYear; this.color = color; this.maxSpeed = maxSpeed; this.currentSpeed = 0; 위의 예제처럼 클래스의 생성자(constructor)는 어떠한 반환값도 명시하지 않음에 주의해야 한다.생성자의 호출자바에서는 new 키워드를 사용하여 객체를 생성할 때 자동으로 생성자가 호출됩니다.class Car { private String modelName; private int modelYear; private String color; private int maxSpeed; private int currentSpeed; Car(String modelName, int modelYear, String color, int maxSpeed) { this.modelName = modelName; this.modelYear = modelYear; this.color = color; this.maxSpeed = maxSpeed; this.currentSpeed = 0; } public String getModel() { return this.modelYear + &quot;년식 &quot; + this.modelName + &quot; &quot; + this.color; }}public class Method02 { public static void main(String[] args) { Car myCar = new Car(&quot;아반떼&quot;, 2016, &quot;흰색&quot;, 200); // 생성자의 호출 System.out.println(myCar.getModel()); // 생성자에 의해 초기화되었는지를 확인함. }}실행 결과2016년식 아반떼 흰색기본 생성자(default constructor)자바 컴파일러는 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않으면 자동으로 기본 생성자를 추가한다.기본 생성자는 매개변수를 하나도 가지지 않으며, 아무런 명령어도 포함하고 있지 않다.문법클래스이름() {}다음 예제는 자바 컴파일러가 Car 클래스에 자동으로 추가해 주는 기본 생성자의 예제이다.Car() {}위와 같이 기본 생성자는 어떠한 매개변수도 전달받지 않으며, 기본적으로 아무런 동작도 하지 않는다.다음 예제는 Car 클래스에 생성자를 정의하지 않고, 기본 생성자를 호출하는 예제이다.예제class Car { private String modelName = &quot;소나타&quot;; private int modelYear = 2016; private String color = &quot;파란색&quot;; public String getModel() { return this.modelYear + &quot;년식 &quot; + this.color + &quot; &quot; + this.modelName; }}public class Method03 { public static void main(String[] args) { Car myCar = new Car(); // 기본 생성자의 호출 System.out.println(myCar.getModel()); // 2016년식 파란색 소나타 }}실행 결과2016년식 파란색 소나타만약 매개변수를 가지는 생성자를 하나라도 정의했다면, 기본 생성자는 자동으로 추가되지 않는다.따라서 매개변수를 가지는 생성자를 하나 이상 정의한 후 기본 생성자를 호출하면, 오류가 발생할 것이다.예제class Car { private String modelName; private int modelYear; private String color; private int maxSpeed; private int currentSpeed;① Car(String modelName, int modelYear, String color, int maxSpeed) { this.modelName = modelName; this.modelYear = modelYear; this.color = color; this.maxSpeed = maxSpeed; this.currentSpeed = 0; } public String getModel() { return this.modelYear + &quot;년식 &quot; + this.modelName + &quot; &quot; + this.color; }}public class Method04 { public static void main(String[] args) {② Car myCar = new Car(); // 기본 생성자의 호출③ // Car myCar = new Car(&quot;아반떼&quot;, 2016, &quot;흰색&quot;, 200); // 생성자의 호출 System.out.println(myCar.getModel()); // 생성자에 의해 초기화되었는지를 확인함. }}위의 예제는 ①번 라인에서 4개의 매개변수를 갖는 생성자를 정의하고 있다.따라서 자바 컴파일러는 Car 클래스에 별도의 기본 생성자를 추가하지 않을 것이다.하지만 ②번 라인에서는 기본 생성자를 호출하여 인스턴스를 생성하려고 하고 있다.따라서 자바 컴파일러는 오류를 발생시킬 것이며, ③번 라인과 같이 4개의 매개변수를 전달해야만 인스턴스가 생성될 것이다.this 키워드 이해하기this와 this()this 참조 변수this 참조 변수는 인스턴스가 바로 자기 자신을 참조하는 데 사용하는 변수이다.크게 세 가지의 사용법이 있는데1. 지역변수와 이름이 같은 `멤버변수`를 해당 지역에 접근할 때 2. 자신의 `객체`를 다른 클래스에게 넘길 때 3. 자신의 `생성자`를 호출할 때 예제class Car { private String modelName; private int modelYear; private String color; private int maxSpeed; private int currentSpeed; Car(String modelName, int modelYear, String color, int maxSpeed) { this.modelName = modelName; this.modelYear = modelYear; this.color = color; this.maxSpeed = maxSpeed; this.currentSpeed = 0; } ...}위의 예제처럼 생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우에는 인스턴스 변수 앞에 this 키워드를 붙여 구분해만 한다. 이렇게 자바에서는 this 참조 변수를 사용하여 인스턴스 변수에 접근할 수 있다.이러한 this 참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없다.모든 인스턴스 메소드에는 this 참조 변수가 숨겨진 지역 변수로 존재하고 있다.this() 메소드this() 메소드는 생성자 내부에서만 사용할 수 있으며, 같은 클래스의 다른 생성자를 호출할 때 사용한다.this() 메소드에 인수를 전달하면, 생성자 중에서 메소드 시그니처(매개변수 리스트)가 일치하는 다른 생성자를 찾아 호출해 줍니다.다음 예제는 this 참조 변수와 this() 메소드를 사용한 예제이다.예제class Car { private String modelName; private int modelYear; private String color; private int maxSpeed; private int currentSpeed; Car(String modelName, int modelYear, String color, int maxSpeed) { //&amp;lt;- 3) 인수가 입력된 객체를 생성함 this.modelName = modelName; this.modelYear = modelYear; this.color = color; this.maxSpeed = maxSpeed; this.currentSpeed = 0; } Car() { this(&quot;소나타&quot;, 2012, &quot;검정색&quot;, 160); // &amp;lt;- 2) 매개변수가 있는 다른 생성자를 호출하고 인수를 입력함 } public String getModel() { return this.modelYear + &quot;년식 &quot; + this.modelName + &quot; &quot; + this.color; }}public class Method05 { public static void main(String[] args) { Car tcpCar = new Car(); //&amp;lt;- 1) 매개변수가 없는 생성자를 호출함 System.out.println(tcpCar.getModel()); //&amp;lt;- 4) 생성된 객체에 getModel 메소드를 적용하여 출력한다. }}실행 결과2012년식 소나타 검정색 // 1, 2 , 3 , 4 순서위의 예제에서 매개변수를 가지는 첫 번째 생성자는 this 참조 변수를 사용하여 인스턴스 변수에 접근하고 있다.또한, 매개변수를 가지지 않는 두 번째 생성자는 내부에서 this() 메소드를 이용하여 첫 번째 생성자를 호출한다.이렇게 내부적으로 다른 생성자를 호출하여 인스턴스 변수를 초기화할 수 있다.단, 한 생성자에서 다른 생성자를 호출할 때에는 반드시 해당 생성자의 첫 줄에서만 호출할 수 있다." }, { "title": "자바 입문기4", "url": "/posts/%EC%9E%90%EB%B0%944/", "categories": "Coding, Java", "tags": "느리지만 확실하게 !, langsam aber sicher", "date": "2021-03-09 17:00:00 +0900", "snippet": "Java는 백기선님의 유튜브를 통해 공부한다.목표자바가 제공하는 제어문을 학습하세요.학습할 것 선택문(필수) 반복문(필수) 과제 (옵션) 과제 0. JUnit 5 학습하세요. 인텔리J, 이클립스, VS Code에서 JUnit 5로 테스트 코드 작성하는 방법에 익숙해 질 것. 이미 JUnit 알고 계신분들은 다른 것 아무거나! 더 자바, 테스트 강의도 있으니 참고하세요~ 과제 1. live-study 대시 보드를 만드는 코드를 작성하세요. 깃헙 이슈 1번부터 18번까지 댓글을 순회하며 댓글을 남긴 사용자를 체크 할 것. 참여율을 계산하세요. 총 18회에 중에 몇 %를 참여했는지 소숫점 두자리가지 보여줄 것. Github 자바 라이브러리를 사용하면 편리합니다. 깃헙 API를 익명으로 호출하는데 제한이 있기 때문에 본인의 깃헙 프로젝트에 이슈를 만들고 테스트를 하시면 더 자주 테스트할 수 있습니다. 과제 2. LinkedList를 구현하세요. LinkedList에 대해 공부하세요. 정수를 저장하는 ListNode 클래스를 구현하세요. ListNode add(ListNode head, ListNode nodeToAdd, int position)를 구현하세요. ListNode remove(ListNode head, int positionToRemove)를 구현하세요. boolean contains(ListNode head, ListNode nodeTocheck)를 구현하세요. 과제 3. Stack을 구현하세요. int 배열을 사용해서 정수를 저장하는 Stack을 구현하세요. void push(int data)를 구현하세요. int pop()을 구현하세요. 과제 4. 앞서 만든 ListNode를 사용해서 Stack을 구현하세요. ListNode head를 가지고 있는 ListNodeStack 클래스를 구현하세요. void push(int data)를 구현하세요. int pop()을 구현하세요. 과제 5. Queue를 구현하세요. 배열을 사용해서 한번. ListNode를 사용해서 한번. 선택문 RefJava 언어에서는 특정 데이터의 값에 따라 수행할 구문을 선택하는 문법을 제공한다. 이와 같은 문법을 일반적으로 선택문이라 부르며 switch case 문이라고도 부른다.switch(변수){ // 변수 입력 case 상수: //타입에 맞는 상수가 오면 해당 케이스 실행statment; break; //실행시 break되며 다음 case무시 후 swtich 벗어남 //break가 없으면 아래 모든 case와 default 실행 case 상수: //이전 case에 속하지 않으면 다른 case에 접근statment; break; default: //모든 case에 해당하지 않으면 default 실행statment; break;}예시import java.util.Scanner; //스캐너를 이용하기위해 import한다.public class App { public static void main(String[] args){ Scanner scan = new Scanner(System.in); int num = 1; System.out.println(&quot;정수 입력&quot;); num = scan.nextInt(); switch (num) { case 1: System.out.println(&quot;One&quot;); break; case 2: System.out.println(&quot;Two&quot;); break; case 3: System.out.println(&quot;Three&quot;); break; default: System.out.println(&quot;Other&quot;); break; } }}코드를 작성 후 실행 시켜주면현재 num = scan.nextInt(); 에서 다음 변수 입력을 기다리고 있는데아래에 2를 입력해 주게 되면case 2에 접근하여 실행문을 실행하는 것을 볼 수 있다. 그 후 break 걸리며 switch를 빠져나오고 종료조건문 RefJava 언어에서는 특정 조건에 따라 수행할 작업을 결정하는 조건문을 제공한다. 조건문은 크게 두가지가 있다. 특정 조건이 참일 때 수행할 작업을 표현하는 if 문 특정 조건이 참일 때 수행할 작업과 거짓일 때 수행할 작업을 표현하는 if else 문if 문import java.util.Scanner;public class App { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int num; System.out.println(&quot;정수를 입력하세요.&quot;); num = scan.nextInt(); if ((num % 2) == 0){ // if문 System.out.println(num + &quot;은 짝수&quot;); //블록이 없으면 바로 아래 하나의 구문만 실행 System.out.println(&quot;입력받은 수:&quot; + num); //블록으로 덮어준다면 여러 구문 실행 } }}if문 결과블록{}이 있을 때의 결과 if문의 블록{}을 없앴을 때의 결과 짝수를 입력하였을때 결과if else문import java.util.Scanner;public class App { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int num; System.out.println(&quot;정수를 입력하세요.&quot;); num = scan.nextInt(); if ((num % 2) == 0) { System.out.println(num + &quot;은 짝수&quot;); } else { //거짓일때 System.out.println(num + &quot;은 홀수&quot;); } }}if문과 마찬가지로 실행문이 여러 구문이면 블록으로 감싸준다.if else문 결과반복문코딩을 자동으로 반복하는 구문을 반복문이라고 한다. 반복문에는 for문과 while문이 있다.for문for(int i = 0; i &amp;lt; 10; i==){System.out.println(i);}for문은 위와 같이 나타낼 수 있는데, for다음 (변수초기화; 조건문; 변수 증감식)으로 나타낸다. 결과는 다음과 같다.0123456789while문while(조건){ 반복 실행 영역}while문은 위와 같이 조건이 참이면 반복하는 구문이다. 조건에 true나false값을 넣어도 되고, 변수를 넣은 후 반복문 안에서 변수++등을 이용하여 빠져나오게 만들 수 있다.do while문do while문은 조건과 상관없이 한 번 반복문을 실행하고 조건 충족이 되면 반복문을 다시 실행하는 구문이다. 나머지는 while과 동일continue반복문에 continue;구문이 들어가게 되면 해당 반복문의 반복부분을 뛰어넘고 다음 부분으로 넘어가게 된다. 예를들어,public class Operator { public static void main(String[] args) {int i;int j; for( i = 1; i &amp;lt;= 9 ; i++){ if(i==5){ continue; } System.out.println(i); } } }와 같이 코딩하게 되면, i가 5가 되었을때 continue되어 해당 반복을 뛰어넘는다.12346 //5 를 뛰어넘고 6789break조건문에서와 같이 break를 만나면 바로 반복문을 벗어난다.과제 0. JUnit 5 학습하세요. RefJunit5 란 자바 개발자가 가장 많이 사용하는 단위테스트 프레임워크이다. Java8 이상을 필요로 한다. 3개의 컴포넌트(모듈로 구성) Junit Platform : 테스트의 런처, TestEngine의 인터페이스 API Jupiter : TestEngine의 구현체, junit5 제공 Vintage : TestEngine의 구현체, junit3,4 제공 실제 intelliJ에서 실행시 Junit Platform으로 실행 주석 내용 @Test 메서드가 테스트 메서드임을 나타냄 @ParameterizedTest 메서드가 매개 변수가 있는 테스트임을 나타냅니다. @RepeatedTest 메서드가 반복 테스트를 위한 테스트 템플릿임을 나타냅니다. @TestFactory 메서드가 동적 테스트를 위한 테스트 팩토리임을 나타냅니다 @TestTemplate 메서드가 여러 번 호출되도록 설계된 테스트 사례의 템플릿임을 나타냄 @TestMethodOrder 해당 테스트 클래스에 대한 테스트 메서드 실행 순서를 구성하는 데 사용 　 @Order(정수 값) : 정한 정수 값을 순서대로 설정한다. @TestInstance 해당 클래스에 대한 테스트 인스턴스 수명주기를 구성하는 데 사용 @DisplayName 테스트 클래스 또는 테스트 메서드에 대한 사용자 지정 표시 이름을 선언 　 @DisplayName(“name”) @DisplayNameGeneration 테스트 클래스에 대한사용자 지정 표시 이름 생성기를 선언 @BeforeEach 해당 메서드가 다른 테스트 메서드보다 먼저 실행되어야 함을 나타냄 @AfterEach 해당 메서드가 다른 테스트 메서드 이후에 실행되어야 함을 나타냄 @BeforeAll 해당 메서드가 현재 클래스의 모든 테스트 메서드보다 먼저 실행되어야 함을 나타냄 @AfterAll 해당 메서드가 현재 클래스의 모든 테스트 메서드 이후에 실행되어야 함을 나타냄 @Nested 해당 클래스가 비 정적 중첩 테스트 클래스임을 나타냄 @Tag 클래스 또는 메서드 수준에서 테스트 필터링을위한 태그를 선언하는 데 사용 @Disabled 테스트 클래스 또는 테스트 메서드를 비활성화하는 데 사용 @Timeout 실행이 주어진 기간을 초과시 테스트 메서드들이 실패 @RegisterExtension 필드를 통해 프로그래밍 방식으로 확장하는 데 사용 @TempDir life cycle 또는 테스트에서 필드 또는 매개 변수 주입을 통해 임시 디렉토리를 제공 과제 1. live-study 대시 보드를 만드는 코드를 작성하세요.깃헙 이슈 1번부터 18번까지 댓글을 순회하며 댓글을 남긴 사용자를 체크 할 것.참여율을 계산하세요. 총 18회에 중에 몇 %를 참여했는지 소숫점 두자리가지 보여줄 것.Github 자바 라이브러리를 사용하면 편리합니다.깃헙 API를 익명으로 호출하는데 제한이 있기 때문에 본인의 깃헙 프로젝트에 이슈를 만들고 테스트를 하시면 더 자주 테스트할 수 있습니다.과제 2. LinkedList를 구현하세요.LinkedList에 대해 공부하세요.정수를 저장하는 ListNode 클래스를 구현하세요.ListNode add(ListNode head, ListNode nodeToAdd, int position)를 구현하세요.ListNode remove(ListNode head, int positionToRemove)를 구현하세요.boolean contains(ListNode head, ListNode nodeTocheck)를 구현하세요.과제 3. Stack을 구현하세요.int 배열을 사용해서 정수를 저장하는 Stack을 구현하세요.void push(int data)를 구현하세요.int pop()을 구현하세요.과제 4. 앞서 만든 ListNode를 사용해서 Stack을 구현하세요.ListNode head를 가지고 있는 ListNodeStack 클래스를 구현하세요.void push(int data)를 구현하세요.int pop()을 구현하세요.과제 5. Queue를 구현하세요.배열을 사용해서 한번ListNode를 사용해서 한번." }, { "title": "자바 입문기3", "url": "/posts/%EC%9E%90%EB%B0%943/", "categories": "Coding, Java", "tags": "느리지만 확실하게 !, langsam aber sicher", "date": "2021-03-02 17:00:00 +0900", "snippet": "Java는 백기선님의 유튜브를 통해 공부한다.목표자바가 제공하는 다양한 연산자를 학습하세요.학습할 것 산술 연산자 비트 연산자 관계 연산자 논리 연산자 instanceof assignment(=) operator 화살표(-&amp;gt;) 연산자 3항 연산자 연산자 우선 순위 (optional) Java 13. switch 연산자연산자(Operater) RefRef연산자는 하나, 둘 또는 세 개의 피연산자에 대해 특정 연산을 수행한 다음 결과를 반환하는 특수 기호이다. 연산자는 각 기호별로 다양한 연산자들이 존재하는데 수학의 연산자들중 곱셈을 덧셈보다 먼저하듯이각 연산자끼리의 연산 우선 순위가 정해져있다. 연산자 우선 순위 최우선 연산자 ( ) : 우선순위 변경을 위해사용 [ ] : 배열의 크기나 첨자를 나타낼 때 사용단항(Unary)연산자단항 연산자에는 피연산자가 하나만 필요하다. 값 1 씩 증가 / 감소, 표현식 부정 또는 부울 값 반전과 같은 다양한 작업을 수행한다. 연산자 + // 단항 더하기 연산자. 양수값을 나타냄 (하지만 이것이 없으면 양수 임). - // 단항 빼기 연산자. 2의보수 연산자 or 부호바꿈연산자 ++ // 증가 연산자. 값을 1 씩 증가 (왼쪽 오른쪽 둘다 가능 -&amp;gt; 위치에 따라 값이 다름) -- // 감소 연산자. 값을 1 씩 감소 (왼쪽 오른쪽 둘다 가능 -&amp;gt; 위치에 따라 값이 다름) ! // 부울대수 NOT(true -&amp;gt; false, false -&amp;gt; true) ~ // 1의 보수를 구해주는 연산자. 양수의 1의 보수의 부호는 음수가 되고 절대값 1증가 음수의 1의 보수의 부호는 양수가 되고 절대값 1감소 단항 연산자 예제public class Unary { public static void main(String args[]) { int a = 10, b = -10; boolean c = true, d = false; System.out.println(&quot;a= &quot; + a + &quot;\\t b=&quot; + b + &quot;\\t c=&quot; + c + &quot;\\t d=&quot; + d); System.out.println(&quot;~a=&quot; + ~a); // -11 1의 보수 연산(양수-&amp;gt; 음수 부호가 바뀌고 1증가됨) System.out.println(&quot;~b=&quot; + ~b); // 9 음수-&amp;gt; 양수 부호가 바뀌고 1감소됨 System.out.println(&quot;!c=&quot; + (!c) + &quot;\\t !d = &quot; + (!d)); // true -&amp;gt; false, false -&amp;gt; true System.out.println(&quot;+a=&quot; + (+a) + &quot;\\t +b = &quot; + (+b)); // &#39;+&#39;는 형식적 제공 System.out.println(&quot;-a= &quot; + (-a) + &quot;\\t -b = &quot; + (-b)); // &#39;-&#39;는 2의보수 연산자 or 부호바꿈연산자 }}단항 연산자 결과 증감연산자 예제public class Operator{ public static void main(String args[]) { int a = 10, b = 5; System.out.println(&quot;a = &quot; + a +&quot;\\t b = &quot; + b); ++a; --b; System.out.println(&quot;a = &quot; + a +&quot;\\t b = &quot; + b); a++; b--; System.out.println(&quot;a = &quot; + a +&quot;\\t b = &quot; + b); // 증감을 하기 전에 명령문을 먼저 처리하므로 10 출력 System.out.println(&quot;후위 연산 a = &quot; + a++); // 명령문이 처리후 증감한 a값 확인 System.out.println(&quot;a 증가 = &quot; + a); // 증감을 한 후에 명령문을 처리하므로 11 출력 System.out.println(&quot;전위 연산 a = &quot; + ++a); }}증감 연산자 결과 산술연산자 + // 더하기 연산자 (문자열 연결에도 사용됨) - // 빼기 연산자 * // 곱셈 연산자 / // 나눗셈 연산자 % // 나머지 연산자 ( A % B = A를 B로 나눈 나머지)산술연산자 예제public class Operator{ public static void main(String args[]) { byte a = 10; byte b = 20; //byte c = a + b; 일경우 a, b 모두 int 형으로 변환 되어 연산 되기 때문에 에러 발생. byte c = (byte)(a + b); // 형변환을 통해 byte 데이터 타입으로 바꿔주고 계산해야 한다. System.out.println(c); }} 결과값 30비트 시프트 연산자 x &amp;lt;&amp;lt; y 　:　 정수 x의 각 비트를 y만큼 왼쪽으로 이동. (빈자리는 0으로 채워짐) x &amp;gt;&amp;gt; y 　:　 정수 x의 각 비트를 y만큼 오른쪽으로 이동. (빈자리는 정수 x의 최상위 부호비트와 같은 값으로 채워짐.) x &amp;gt;&amp;gt;&amp;gt; y　 :　 정수 x의 각 비트를 y만큼 오른쪽으로 이동. (빈자리는 0으로 채워짐)비트시프트연산자 예제public class Operator{ public static void main(String args[]) { int temp; System.out.println(8); System.out.println(Integer.toBinaryString(8)); temp = 8 &amp;gt;&amp;gt; 2; System.out.println( &quot;8 &amp;gt;&amp;gt; 2 = &quot; + temp); System.out.println(Integer.toBinaryString(temp)); System.out.println(-8); System.out.println(Integer.toBinaryString(-8)); temp = -8 &amp;lt;&amp;lt;2; System.out.println(&quot;-8 &amp;lt;&amp;lt; 2 = &quot; + temp); System.out.println(Integer.toBinaryString(temp)); System.out.println(-8); System.out.println(Integer.toBinaryString(-8)); temp = -8 &amp;gt;&amp;gt; 2; System.out.println( &quot;-8 &amp;gt;&amp;gt; 2 = &quot; + temp); System.out.println(Integer.toBinaryString(temp)); System.out.println(-8); System.out.println(Integer.toBinaryString(-8)); temp = -8 &amp;gt;&amp;gt;&amp;gt; 2; System.out.println( &quot;-8 &amp;gt;&amp;gt;&amp;gt; 2 = &quot; + temp); System.out.println(Integer.toBinaryString(temp)); }}비트시프트 결과 관계연산자두 항의 크기,값을 비교하는 연산자.연산의 값은 true, false &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;= 　:　 두 피 연산자의 크기를 비교(boolean형을 제외한 나머지 자료형 사용가능) ==, != 　:　 두 피연산자의 값이 같은지 비교논리연산자논리연산자는 이항 연산자로 조건의 참, 거짓을 비교하는 조건 논리 연산자와 비트 논리 연산자로 나뉜다.조건 논리 연산자 (||, &amp;amp;&amp;amp;) : boolean형의 값을 결과로 하는 조건식만 허용 (조건문, 반복문에서 많이 사용된다.) ||은 OR 결합이고 &amp;amp;&amp;amp;은 AND결합이다.비트 논리 연산자(|,&amp;amp;,^,~) : 피연산자끼리 이진 비트 연산을 수행해서 결과를 정수로 반환하는 연산자 (정수형만 사용가능) * |은 OR연산자, &amp;amp;은 AND연산자, ^은 XOR연산자, ~은 NOT연산자이다. * OR 둘 중 하나라도 1 이면 OR값은 1 * AND 둘 중 하나라도 0 이면 혹은 둘 다 1이면 AND값은 0 * XOR 둘이 같으면 0 다르면 1논리연산자 예제public class Operator{ public static void main(String args[]) { boolean pan; int x = 3; int y = 5; pan = 10 &amp;gt; 3 &amp;amp;&amp;amp; 3 &amp;lt; 10; // (10 &amp;gt; 3 = true) AND (3 &amp;lt; 10 = true) = true System.out.println(&quot;pan:&quot; + pan); pan = 10 &amp;gt; 3 || 3 &amp;lt; 10; // (10 &amp;gt; 3 = true) OR (3 &amp;lt; 10 = true) = true System.out.println(&quot;pan:&quot; + pan); System.out.println(&quot;x는 &quot; + x + &quot;이고, y는 &quot; + y + &quot;일때, &quot;); System.out.println(&quot;x | y = &quot; + (x | y)); // ( 11 과 101 OR연산) System.out.println(&quot;x &amp;amp; y = &quot; + (x &amp;amp; y)); // ( 11 과 101 AND연산) System.out.println(&quot;x ^ y = &quot; + (x ^ y)); // ( 11 과 101 XOR연산) System.out.println(&quot;~x = &quot; + ~x); // ( 11 NOT) System.out.println(&quot;true | false = &quot; + (true | false)); System.out.println(&quot;true &amp;amp; false = &quot; + (true | false)); System.out.println(&quot;true ^ false = &quot; + (true ^ false)); }}논리연산자 결과instanceof 연산자 RefRef참조변수가 참조하고 있는 ‘인스턴스’의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.주로 조건문에 사용되며, instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다.그리고 연산의 결과로 boolean값인 true, false 중의 하나를 반환한다.instanceof를 이용한 연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.즉, 왼쪽 참조변수(인스턴스)가 오른쪽 타입(클래스)로 형변환이 가능한지(클래스에 속하는지)에 대해 연산하는 연산자이다. 또한, true false 값을 나타내기 때문에 조건문을 사용한다. 값이 null인 참조변수에 대해 instanceof 연산을 수행하면 flase를 결과로 얻는다.obj1,2의 instanceof 예제public class Operator { public static void main(String[] args) { Parent obj1 = new Parent(); Parent obj2 = new Child(); System.out.println(&quot;obj1 instanceof Parent: &quot; + (obj1 instanceof Parent)); System.out.println(&quot;obj1 instanceof Child: &quot; + (obj1 instanceof Child)); System.out.println(&quot;obj1 instanceof MyInterface: &quot; + (obj1 instanceof MyInterface)); System.out.println(&quot;obj2 instanceof Parent: &quot; + (obj2 instanceof Parent)); System.out.println(&quot;obj2 instanceof Child: &quot; + (obj2 instanceof Child)); System.out.println(&quot;obj2 instanceof MyInterface: &quot; + (obj2 instanceof MyInterface)); }}class Parent {}class Child extends Parent implements MyInterface {}interface MyInterface {}instanceof 결과assignment(=) operator(대입연산자)대입 연산자는 2항 연산자로 좌측 피연산자에 우측 피연산자를 연산후 대입하는 연산자이다. 예를 들어i = 10; // 변수 i에 10을 대입i += 10 // 변수 i에 10을 더한 후 대입 i의 초기값이 10이었다면 10+10 이 i 즉, i의 값은 20이 된다.대입 연산자의 종류로는x += y; // x = x+yx -= y; // x = x-yx *= y; // x = x*yx /= y; // x = x/yx %= y; // x = x%yx &amp;lt;&amp;lt;= y; // x = x&amp;lt;&amp;lt;yx &amp;gt;&amp;gt;= y; // x = x&amp;gt;&amp;gt;yx &amp;amp;= y; // x = x&amp;amp;yx ^= y; // x = x^yx |= y; // x = x!y등이 있다.화살표(-&amp;gt;) 연산자(람다)자바8 에서 부터 화살표 즉, 람다 연산자가 추가되었는데 람다식이란 “식별자없이 실행가능한 함수”이다. 함수인데 함수를 따로 만들지 않고 코드한줄에 함수를 써서 그것을 호출하는 방식이다.람다의 장단점장점 람다를 사용하면 불필요한 반복문의 삭제가 가능하며 복잡한 식을 단순하게 표현 가능 람다는 지연연상을 수행 함으로써 불필요한 연산을 최소화 가능 멀티쓰레디를 활용하여 병렬처리를 사용 가능 단점 람다식의 호출이 까다로움 람다 stream 사용 시 단순 for문 혹은 while문 사용 시 성능하락 불필요하게 너무 사용하게 되면 오히려 가독성이 떨어진다. 람다식 사용법 Ref(매개변수, ...) -&amp;gt; { 실행문 ... }왼쪽에 메소드(또는 함수)에서 사용 할 매개변수를 나열한다.예를 들어@FunctionalInterfaceinterface Say{ int someting(int a,int b);}class Person{ public void hi(Say line) { int number = line.someting(3,4); System.out.println(&quot;Number is &quot;+number); }}예를들기 위해 Person이라는 Class와 Say라는 Functional Interface를 만들었다. Functional Interface란 함수가 하나만 존재하는 Interface를 의미한다.원래는 다음과 같이 작성하지만Person rin = new Person();rin.hi(new Say() { public int someting(int a, int b) { System.out.println(&quot;My Name is Coding-Factory&quot;); System.out.println(&quot;Nice to meet you&quot;); System.out.println(&quot;parameter number is &quot;+a+&quot;,&quot;+b); return 7; }});람다를 사용하게 되면Person rin = new Person();rin.hi((a,b) -&amp;gt;{ System.out.println(&quot;This is Coding-Factory!&quot;); System.out.println(&quot;Tank you Lamda&quot;); System.out.println(&quot;parameter number is &quot;+a+&quot;,&quot;+b); return 7;});이렇게 표현할 수 있다. 매개 변수가 하나라면 ()소괄호를 생략가능 실행문이 한 문장이라면 {}중괄호도 생략가능람다식 예제 두개의 숫자 더하기interface Compare{ public int compareTo(int a, int b);}public class Ramda2 { //람다식 문법 (매개변수 목록)-&amp;gt;{실행문} public static void exec(Compare com) { int k = 10; int m = 20; int value = com.compareTo(k, m); System.out.println(value); } public static void main(String[] args) { exec((i,j)-&amp;gt;{ return i+j; }); }} 결과값 30 두개의 숫자중 큰 수 찾기 import extendsss.main;public class Ramda3 { @FunctionalInterface//함수형 인터페이스 체크 어노테이션 public interface MyNumber{ int getMax(int num1, int num2); } public static void main(String[] args) { MyNumber max = (x,y)-&amp;gt;(x&amp;gt;=y)? x:y; System.out.println(max.getMax(10, 30)); }} 결과값 30 Runnable 인스턴스 생성 public class RunnableEx { public static void main(String[] args) { Runnable runnable = () -&amp;gt; { for (int i = 0; i &amp;lt; 30; i++) { // 조건 : i가 30 보다 작으면 실행 System.out.println(i); } }; Thread thread = new Thread(runnable); thread.start(); }} 결과값 0123...2829 3항 연산자int a = (5&amp;lt;4) ? 50 : 40;// 조건문 ? 참일때 : 거짓일떄 System.out.println(a);조건문의 참과 거짓에 따라 변수 a 에 담기는 값이 변하게 된다.결과는 거짓이므로 40이 출력된다.Java 13. switch 연산자 RefJava12부터 switch 연산자가 추가 되었다. 기존에 switch문이 변경된것이 아니라 switch 연산자가 추가 된것이다.switch 문(statement) 다수의 case,break가 존재하게 된다. break; 를 빼먹을 경우 다음 분기로 넘어가게 됨. return값이 존재할수없다.Switch 연산자(operator) break;를 사용하지 않아도 된다. yield 존재함 return값 존재해도됨 case -&amp;gt; A 같은 형식으로 표현가능switch의 반환값이 따로 필요하지 않거나 case가 switch 들어오는 모든 인자를 커버하는 경우default 항목을 넣어주지 않아도 되나 그렇지 않은 경우는 default -&amp;gt; code를 작성해야 한다.Java12 -&amp;gt;(화살표) 표현이 가능하고 data만 존재할 경우 return이 가능하다. -&amp;gt; 구문을 사용할 경우 break;를 적지 않아도 다음 case 구문으로 넘어가지 않는다. -&amp;gt; 표현 오른쪽은 꼭 단일 수행일 필요는 없다. 블록 {} 안에서의 작업도 가능하다. Java13 yield 예약어가 추가됨. yield x 하게 되면 x가 리턴됨. yield는 예약어이지만 변수명으로 사용가능하다.int yield = 3; public class Main { public static void main(String[] args) { //Java 12 이전 int num = 1; int returnNum = 0; switch(num){ case 1: returnNum = 1; System.out.println(&quot;1들어옴&quot;); break; case 2: returnNum = 2; System.out.println(&quot;2들어옴&quot;); break; case 3: returnNum = 3; System.out.println(&quot;3들어옴&quot;); break; } System.out.println(&quot;returnNum : [ &quot; + returnNum + &quot; ]&quot;); //Java 12 returnNum = switch(num){ case 1 -&amp;gt; 1; case 2 -&amp;gt; 2; default -&amp;gt; throw new IllegalStateException(&quot;Unexpected value: &quot; + num); }; System.out.println(&quot;returnNum : [ &quot; + returnNum + &quot; ]&quot;); //Java13 returnNum = switch(num){ case 1 : yield 3; default : throw new IllegalStateException(&quot;unexpected value : &quot; + num); }; System.out.println(&quot;returnNum : [ &quot; + returnNum + &quot; ]&quot;); }} 결과 1들어옴returnNum : [ 1 ]returnNum : [ 1 ]returnNum : [ 3 ] " }, { "title": "Android Studio4 앱 실습", "url": "/posts/%EC%95%88%EC%8A%A44/", "categories": "Coding, Android Studio", "tags": "느리지만 확실하게 !, langsam aber sicher", "date": "2021-02-16 19:47:00 +0900", "snippet": "Ref.한빛미디어 안드로이드프로그래밍 목표위 앱과 같이 구성하기 위하여 위젯을 코딩한다.위젯 코딩그 후 각 위젯의 동작을 설정하기위하여 java로 코딩해준다.동작코딩그럼 실제 동작화면을 확인해 보자.시작스위치 ON시작 스위치를 누르면 텍스트 출력과 함께라디오버튼들이 나오게 된다.Q버튼 클릭라디오 버튼을 클릭하면 해당 버전을 의미하는 이미지가 출력된다. R버튼 클릭R버튼을 누르면 Q의 사진이 사라지고 R사진이 출력된다.처음으로 버튼 클릭처음으로 버튼을 눌러 초기화면 돌아가며 토스트 메세지가 뜬다." }, { "title": "Android Studio3 계산기 앱 만들기", "url": "/posts/%EC%95%88%EC%8A%A43/", "categories": "Coding, Android Studio", "tags": "느리지만 확실하게 !, langsam aber sicher", "date": "2021-02-14 14:47:00 +0900", "snippet": "ref. 안드로이드프로그래밍 of 한빛미디어초간단 계산기 만들기실습 목표 결과우선 보이는 것과 같이 구성하기 위하여 activity_main.xml에 위젯들을 추가해준다. &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;EditText android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/Edit1&quot; &amp;lt;----닉네임 설정 android:hint=&quot;@string/str1&quot; &amp;lt;---- string.xml 에서 str1의 텍스트를 불러옴 android:layout_margin=&quot;10dp&quot; /&amp;gt; ~~~~~~~~~~~~~~생략~~~~~~~~~~~~~~~~~ &amp;lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/BtnAdd&quot; android:text=&quot;더하기&quot; android:layout_margin=&quot;10dp&quot; &amp;lt;----다른 위젯이나 레이아웃과 거리를 둠 /&amp;gt; ~~~~~~~~~~~~~~생략~~~~~~~~~~~~~~~~~ &amp;lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/TextResult&quot; android:text=&quot;계산 결과 : &quot; android:layout_margin=&quot;10dp&quot; android:textSize=&quot;30dp&quot; &amp;lt;----글씨 크기 android:textColor=&quot;#FF0000&quot; &amp;lt;---글씨색 (빨강) #RRGGBB 진하기 최대값 FF /&amp;gt;이후 MainActivity로 넘어가 Java로 코딩한다.우선 다음과 같이 변수를 선언한다.그 후 메소드를 구성한다.변수 대입이후에 각 버튼 터치시 동작을 설정해준다.동작설정각 뺴기 곱하기 나누기 등은 result = Integer.parseInt(num1) + Integer.parseInt(num2);부분에서 +를 각 -,*,/,% 로 바꿔준다." }, { "title": "자바 입문기2", "url": "/posts/%EC%9E%90%EB%B0%942/", "categories": "Coding, Java", "tags": "느리지만 확실하게 !, langsam aber sicher", "date": "2021-02-02 17:00:00 +0900", "snippet": "Java는 백기선님의 유튜브를 통해 공부한다.목표자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.학습할 것 프리미티브 타입 종류와 값의 범위 그리고 기본 값 프리미티브 타입과 레퍼런스 타입 리터럴 변수 선언 및 초기화하는 방법 변수의 스코프와 라이프타임 타입 변환, 캐스팅 그리고 타입 프로모션 1차 및 2차 배열 선언하기 타입 추론, var프리미티브 타입과 레퍼런스 타입데이터에는 다양한 타입이 존재한다. 그 중 자바의 데이터값의 타입들은 다음과 같이 나눠진다.자바 데이터타입 (ref 뇌를자극하는 Java 프로그래밍 - 한빛미디어)프리미티브 타입 타입 할당되는 메모리 크기 기본값 데이터의 표현 범위논리형 boolean 1 byte false true, false정수형 byte 1 byte 0 -128 ~ 127 short 2 byte 0 -32,768 ~ 32,767 int(기본) 4 byte 0 -2,147,483,648 ~ 2,147,483,647 long 8 byte 0L -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 실수형 float 4 byte 0.0F (3.4 X 10-38) ~ (3.4 X 1038) 의 근사값 double(기본) 8 byte 0.0 (1.7 X 10-308) ~ (1.7 X 10308) 의 근사값 문자형 char 2 byte (유니코드) &#39;\\u0000&#39; 0 ~ 65,535 특징 자바 언어에 내장된 기본 유형으로 기본형 타입(primitive type)을 미리 정의하여 제공 기본값이 있기 때문에 Null이 존재하지 않음 실제 값을 저장하는 공간으로 stack 메모리에 저장 wrapper class는 각 privitive type을 클래스로 만든것 레퍼런스타입타입 예시 기본값 할당되는 메모리 크기 배열 int[] arr = new int[5]; Null 4Byte (객체의 주소값) 열거 Null &#39;&#39;클래스 String str = &quot;test&quot;; Null &#39;&#39; Student sujin = new Student(); Null &#39;&#39; 인터페이스 Null &#39;&#39; 특징 기본형(primitive) 타입을 제외한 타입들이 모두 참조형 타입이다. 빈 객체를 의미하는 Null 존재 값이 저장되어 있는 곳의 주소값을 저장하는 공간으로 힙(Heap) 메모리에 저장 Ref리터럴 변수(variable) : 하나의 값을 저장하기 위한 공간 상수(constant) : 값을 한번만 저장할 수 있는 공간 리터럴(literal) : 그 자체로 값을 의미하는 것int year = 2017 ; final int MAX_VALUE = 100 ;----------------------------------------------변수 : year상수 : MAX_VALUE리터럴 : 2017, 100 변수 변수 단 하나의 값을 저장할 수 있는 메모리 공간을 의미한다. 변수의 선언 변수에 저장될 값의 타입을 지정하고 변수에 이름을 붙여주는 것을 의미한다. ex) int score ; // 정수형 타입의 score 변수를 선언 변수의 초기화 변수를 사용하기 전에 처음으로 값을 저장하는 것을 의미한다 ex) int score = 100 ; // 정수형 타입의 score 변수를 선언하고, 100으로 초기화 변수 명명 규칙 대소문자가 구분되며 길이에 제한이 없다. max ≠ Max 숫자가 맨 앞에 올 수 없다. main1( o ) 1main ( x ) 특수문자는 _ 와 $만을 허용하며, 중간에 공백문자도 허용되지 않는다. $harp( o ) S#arp( x ) apple_tree( o ) 키워드는 사용할 수 없다. true( x ) True( o ) 스코프와 라이프타임변수와 메서드 같은 것들을 사용할수 있는 것은 이름이 있기 때문이다.프로그램이 커지면 여러가지 이유로 이름이 충돌하게 된다. 이를 해결하기 위해 고안된것이 Scope이다. 때문에 변수들은 사용 가능한 범위를 가진다. 그 범위를 변수의 스코프라고 한다. 라이프타임 Lifetime 은 수명이라고 생각하면된다.public class test { int iv; // 인스턴스 변수 static int cv; // 클래스 변수 void method() { int lv; // 지역 변수 } } 인스턴스 변수(Instance Variables) 스코프scope : 클래스 전체(static제외) 라이프타임 lifetime : 객체가 메모리에 머무를때 까지 클래스 변수(Class Variables) 스코프scope : 클래스 전체 라이프타임 lifetime : 프로그램의 수명이 끝날때까지 또는 클래스가 메모리에 로드 되는 한 지역 변수(Local Variables) 스코프scope : 선언된 블록 내 라이프타임 lifetime : 선언된 블록을 벗어날때 형변환(캐스팅, casting)형변환이란 변수 또는 상수의 타입을 다른 타입으로 변환하는 것을 말한다.프로그램에서 값의 대입이나 연산을 수행할 때는 같은 타입끼리만 가능하다.그래서 연산을 수행하기 전에 같은 타입으로 만들어야 하는데, 변수나 상수를 다른 타입으로 변환하는 것을 ‘형변환(casting)’ 이라고 한다.타입을 그릇으로 보면 각 그릇의 크기가 다른데 그 안에 담기는 양도 재각기이다.작은 그릇에 가득 차 있어도 큰 그릇에는 여유가 있지만 반대로, 큰 그릇에 가득 차 있으면 작은 그릇에 담을 때 넘칠 것이고,큰 그릇에 적게 들어있으면 작은 그릇에도 담아질 것이다. 이처럼 작은 그릇에서 큰그릇은 문제가 없지만 큰그릇에서 작은그릇에 담을땐 주의해야한다.형변환에서는 이런 경우, 자동 형변환과 강제 형변환이 있다.자동형변환형변환 구조왼쪽에서 오른쪽으로는 자동 형변환이 가능하고, 반대는 강제로 형변환을 해주어야 한다.int intValue = 1; byte byteValue = (byte) intValue; &amp;lt;- 인트변수을 바이트에 대입함 (byte)intValue; 변수앞에 강제형변환 타입을 ()안에 작성한다.1차 및 2차 배열 선언하기 Ref1차원 배열배열은 같은 데이터 타입을 가진 연속된 메모리 공간으로 이루어진 자료구조이다. 같은 데이터 타입을 가진 여러개의 변수가 필요할 때 사용한다.배열의 크기는 0이상의 정수값으로 정하며 [0,1,2,3,4,5,6’’‘]의 주소를 가진다. 배열은 Default 값을 갖게되는데 타입마다 다르다. 참조 타입 = null int , short , byte , long 타입 = 0 float / double 타입 = 0.0 bool 타입 = false char 타입 = \\u0000배열 생성int[] array1 = new int[4];타입[] 변수명 = new 타입[크기]; 크기가 4인 int타입의 배열을 생성하였다. 배열에 변수를 저장하는 방법 array1[0] = 1; 0부터 시작하여 array1[1] = 2; 0,1,2,3의 주소를 갖고 있다. array1[2] = 3; &amp;lt;- 이렇게 주소에 변수를 저장할 수 있다. array1[3] = 4;변수를 사용하는 방법 int value = array1[2]; &amp;lt;–array1 배열의 2번 주소의 변수를 value에 담는다. System.out.println(array1[1]); &amp;lt;– 배열의 1번 주소 변수를 출력한다.선언과 동시에 초기화하는 방법int[] array2 = new int[]{1,2,3,4,5};2차원 배열1차원 배열과 비슷하지만 1차원 배열들의 배열을 2차원 배열이라 할 수 있다. 예를 들면 다음과 같다.int[][] array4 = new int[3][4]; // 1차원 배열을[3]개 구성하고 그 안에[4]개의 변수주소를 갖는다.array4 -&amp;gt; 0 [0,0,0,0] 1 [0,0,0,0] 2 [0,0,0,0] 변수 저장 방법 array4[0][0] = 10; //array4의 0번째 배열에 0번째 주소에 10을 저장한다. 가변크기의 2차원 배열을 생성하는 방법 int[][] array5 = new int[3][]; 위와 같이 선언하면 array5는 3개짜리 배열을 만든다. 3개짜리 배열은 아직 변수를 저장하는 공간이 없다. array5[0] = new int[2]; array5 의 0 번째 배열에 1개의 변수를 저장하는 공간을 만든다. array5[1] = new int[2]; array5 의 1 번째 배열에 2개의 변수를 저장하는 공간을 만든다. array5[2] = new int[3]; array5 의 2 번째 배열에 3개의 변수를 저장하는 공간을 만든다. 선언과 동시에 초기화하는 방법 .타입추론(Type Inference) ‘var’ Ref타입 추론이란 변수등을 초기화 또는 선언할때 타입을 정해주지 않아도 컴파일러가 코드를 초기화값을 보고 타입을 추론해 나가는 동작을 의미한다.java 9까지는 generics와 lambda식에 대해 타입 추론을 지원하고 있었지만Java 10에서 일반 타입의 타입추론을 위해 var라는 Local Variable Type-Inference 가 추가되었다타입 추론의 기본 String message = “Good bye, Java 9”; 가 기본이라면 var message = “Hello, Java 10”; 처럼 타입 추론을 사용할 수 있다. 이 경우 var은 message의 타입을 String 으로 처리할 것이다.var의 특징 지역변수로서만 선언 가능하다. 사용시 초기화값이 선언되어야 한다. 키워드가 아니다. 예를 들어 int는 함수나 변수의 이름이 불가하지만 var는 이름으로 사용 가능 사용시 런타임 오버 헤드 가 없으며 Java를 동적 유형 언어로 만들지 않는다.var 유의사항 선언시 초기화값을 지정해 줘야한다. var n; // error: cannot use &#39;var&#39; on variable without initializer null값으로 초기화 할 수 없다. var emptyList = null; // error: variable initializer is &#39;null&#39; Lambda 식에는 명시적인 대상 유형이 필요하므로 var를 사용할 수 없다. var p = (String s) -&amp;gt; s.length() &amp;gt; 10; //error:lambda expression needs an explicit target-type 배열에 사용할 수 없다. var arr = { 1, 2, 3 }; // error: array initializer needs an explicit target-type 따라서, 가독성이 떨어질 때 사용하는 것을 추천한다." }, { "title": "자바 입문기", "url": "/posts/%EC%9E%90%EB%B0%941/", "categories": "Coding, Java", "tags": "느리지만 확실하게 !, langsam aber sicher", "date": "2021-01-29 17:59:00 +0900", "snippet": "Java는 대표적인 객체지향 프로그래밍 언어이다.Java는 백기선님의 유튜브를 통해 공부한다.목표자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기.학습할 것 JVM이란 무엇인가 컴파일 하는 방법 실행하는 방법 바이트코드란 무엇인가 IT 컴파일러란 무엇이며 어떻게 동작하는지 JVM 구성 요소 JDK와 JRE의 차이 javac 조사JVM이란? JAVA Virtual Machine으로서 역할은 자바 애플리케이션을 클래스 로더를 통해 자바 API와 함께 실행하는 것이다.JVM은 JAVA가 OS에 구애받지 않고 재사용을 가능하게 해준다. 그리고 가장 중요한 메모리관리, Garbage collection을 수행한다.자바프로그램 실행과정 프로그램이 실행되면 JVM은 OS로부터 필요로 하는 메모리를 할당받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다. 자바 컴파일러(javac)가 자바 소스코드(.java)를 -&amp;gt; 자바 바이트코드(.class)로 변환시킨다. Class Loader를 통해 class파일들을 JVM으로 로딩한다. 로딩된 class파일들은 Execution engine을 통해 해석된다. 해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어지게 된다. 이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리작업을 수행한다.JVM 구성 Class Loader(클래스 로더) Execution Engine(실행 엔진) Runtime Data AreaClass Loader(클래스 로더) JVM내로 클래스(.class파일)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다. Runtime 시 동적으로 클래스를 로드한다. jar파일 내 클래스들을 JVM위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제한다. (컴파일러 역할) 자바는 동적코드, 컴파일 타임이 아니라 런타임에 참조한다. 즉, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한다는 것이다. 그 역할을 클래스 로더가 수행한다.Execution Engine(실행 엔진) 클래스를 실행시키는 역할이다. 클래스 로더가 JVM내의 런타임 데이터 영역에 바이트코드를 배치시키고, 실행엔진에 의해 실행된다. 바이트코드를 실제로 JVM내부에서 기계가 실행할 수 있는 형태로 변경한다. 이 때 두 가지 방식을 사용하게 된다. Interpreter(인터프리터) 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다. 하지만 이 방식은 인터프리터 언어의 단점을 그대로 갖고 있다. 한 줄 씩 수행하기 때문에 느리다는 것이다. JIT(Just - In - Time) 인터프리터 방식으로 실행하다가 반복적인 바이트코드 전체를 컴파일해 네이티브 코드로 변경하고, 이후에는 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식이다. 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행하게 된다. 단, JIT컴파일러가 컴파일하는 과정은 훨씬 오래걸려 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅하는 것이 유리하다. Garbage collector GC를 수행하는 모듈 (쓰레드)이 있다.Runtime Data Area Runtime Data Area 구조 Method Area -필드 정보(클래스 멤버 변수명, 데이터 타입, 접근 제어자 정보) -메소드 정보(메소드명, 리턴 타입, 접근 제어자 정보) -Type 정보(Interface인지 Class인지) -Constant Pool(상수 풀: 문자 상수, 타입, 필드, 객체 참조 저장) -static 변수 -inal 클래스 변수 등 Native Method Stack 자바외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다 보통 C/C++등의 코드를 수행하기 위한 스택이다 (JNI) Stack Area 지역변수, 파라미터, 리턴 값, 연산에 사용되는 임시값 등을 저장 int a = 10 을 예로 들면 정수값이 할당될 수 있는 메모리 공간을 a라고 잡아두고 그 메모리 영역에 10을 넣는다. 클래스 A a = new A()의 경우 A a는 스택영역에 저장되고 new로 생성된 A클래스의 인스턴스는 Heap영역에 생성된다. 또한 스택영역에 생성된 a는 힙영역의 주소값을 가지고 있다. 즉 a가 heap영역에 생성된 객체를 가리키며 참조하고 있다. 메소드 호출시마다 개별적으로 스택이 생성된다. PC Register Thread가 생성될 때마다 생성되는 영역으로 Program Counter 즉, 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다. 이것을 이용해 쓰레드를 돌아가면서 수행한다 Heap Area 객체를 저장하는 가상 메모리 공간이다. new연산자로 생성된 객체와 배열을 저장한다. 물론 class area영역에 올라온 클래스들만 객체로 생성할 수 있다. 힙은 Permanent Generation, New/Young 영역, Old 영역 세 부분으로 나눌 수 있다. Heap Area 구조 Heap구조 Permanent Generation 생성된 객체들의 정보의 주소값이 저장된 공간이다. 클래스로더에 의해 로드되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용된다. Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용된다. 내부적으로 Reflection 기능을 자주 사용하는 Spring Framework를 이용할 경우 이영역에 대한 고려가 필요하다. New/Young 영역 Eden : 객체들이 최초로 생성되는 공간 Survivor 0 / 1 : Eden에서 참조되는 객체들이 저장되는 공간 Old 영역 New area에서 일정 시간 참조되고 있는, 살아남은 객체들이 저장되는 공간 Eden영역에 객체가 가득차게 되면 첫번째 GC(minor GC)가 발생한다. Eden영역에 있는 값들을 Survivor 1 영역에 복사하고 이 영역을 제외한 나머지 영역의 객체를 삭제한다. 인스턴스는 소멸 방법과 시점이 지역 변수와는 다르기에 힙이라는 별도의 영역에 할당된다. 자바 가상 머신은 매우 합리적으로 인스턴스를 소멸시킨다. 더이상 인스턴스의 존재 이유가 없을 때 소멸시킨다. JDK와 JRE의 차이점JRE : Java Runtime Environment, 자바 실행 환경 -&amp;gt; JVM, Java API자바 애플리케이션을 실행하기 위한 최소의 실행 환경 제공.JDK : Java Development Kit, 자바 개발 도구 -&amp;gt; JVM, Java API, Java Tool, Java CompilerJRE에서 제공하는 실행 환경뿐만 아니라 자바 개발에 필요한 여러 가지 명령어 그리고 컴파일러를 포함. (자바 App 메모리상태 알아보는 명령어, 배포 명령어) JRE와 JDK출처:https://jusungpark.tistory.com/13https://asfirstalways.tistory.com/158https://velog.io/@hono2030/JVM%EC%9D%98-%EA%B5%AC%EC%A1%B0" }, { "title": "Android Studio 입문기2", "url": "/posts/%EC%95%88%EC%8A%A42/", "categories": "Coding, Android Studio", "tags": "느리지만 확실하게 !, langsam aber sicher", "date": "2021-01-28 21:51:00 +0900", "snippet": "실행 가능한 앱 만들기전과 마찬가지로 Empty Activity를 고른 후xml 코딩 변경 전이 activity_main.xml 화면에서다음과 같이 코딩하였다.xml 코딩 변경 후 1,2행은 리니어레이아웃의 XML네임스페이스를 URL로 지정하는데 네임스페이스는 전체 코드중 한 번만 나오면 된다.(디폴트 android) 3,4행은 android:~ 가 네임스페이스에 포함됨을 의미 8,9는 버튼의 높이와 너비 10행은 버튼의 아이디를 표현하는데 이름이 button1 이다. 임의로 지정가능하다. 아이디는 “@+id/지정 아이디”로 만드는데, @는 리소스에서 참조하라는 의미이고 @+는 리소스에 추가하라는 의미이다.text는 버튼에 쓰여지는 글자인데 직접 작성하여도 되지만 안드로이드에서는 strings.xml에 문자열을 모아두는것이 좋다고 한다. “@string/문자열이름”은 strings.xml 파일에 해당 문자열이름으로 문자열이 지정되어 있다는 의미이다. 따라서, [res]-[values]-[strings.xml]에 들어가 strBtn1등 문자열을 지정해주도록 한다. import 지정x 오류위과 같이 입력하면 오류가 발생하는데 button관련 클래스 등이 임포트 되지 않았기 때문따라서 직접 임포트해주던가 알트+엔터를 눌러 추가해준다. import 지정코딩 중 자동 입력기능이 있는데 오타방지와 신속함을 위해 자동입력Ctrl+Space Bar 로 입력해주자그 후, MainActivity.java로 넘어가 버튼 클릭시 반응이 있도록 하자.버튼 클릭 코딩 10행 AppCompatActivity 클래스를 상속받아 MainActivity 클래스 정의 11행 버튼에대한 변수 선언 16행 button1 변수에 버튼 객체 대입 18~ 버튼 클릭시 동작 정의실제 동작" }, { "title": "Android Studio 입문기", "url": "/posts/%EC%95%88%EC%8A%A4/", "categories": "Coding, Android Studio", "tags": "느리지만 확실하게 !, langsam aber sicher", "date": "2021-01-28 17:57:00 +0900", "snippet": "안드로이드 스튜디오를 깔고 첫 앱을 만들어 보았다.프로젝트를 생성 시JAVA파일이름은 MaunActivity.java 기본 화면 XML파일 이름은 activity_main.xml 이다Design 탭에서 드래그로 만들수도 있고, 코딩으로 만들수도 있따프로젝트를 만들었을때 기본소스로코딩으로 작업하는 화면Design 툴로 작업하는 화면왼쪽 Project Tree에서 java-com.cookandroid.myfirst 안에MainActivity 나 위의 MainActivity.java를 클릭하여 이 곳의 코드를 수정하면 된다.가장 먼저 시작하는 메소드는 onCreate()이고,setContentView(R.layout.activity_main)메소드는 activity_main.xml을 화면에 표시하라는 의미안스화면4어플 상단왼쪽에 아이콘을 넣기위해 res-drawable 폴더에 ic_launcher 이미지를 넣고MainActivity.java에getSupportActionBar().setDisplayShowHomeEnabled(true);getSupportActionBar().setIcon(R.drawable.ic_launcher);를 코딩하였다" } ]
